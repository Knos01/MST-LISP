;;;; -*- Mode: Lisp -*-

(defparameter *vertices* (make-hash-table :test #'equal))
(defparameter *arcs* (make-hash-table :test #'equal))
(defparameter *graphs* (make-hash-table :test #'equal))
(defparameter *visited* (make-hash-table :test #'equal))
(defparameter *vertex_keys* (make-hash-table :test #'equal))
(defparameter *previous* (make-hash-table :test #'equal))
(defparameter *heaps* (make-hash-table :test #'equal))
(defparameter *heap-entries* (make-hash-table :test #'equal)) 
;;;; chiave (heap-id V) valore (K Pos Parent)

;usare (inspect *hash-table*) per visualizzarne il contenuto

;;;; is-graph/1

(defun is-graph (graph-id)
  (gethash graph-id *graphs*))

;;;; new graph/1

(defun new-graph (graph-id)
 (if (null graph-id)
      (format t "Errore: ~S non e' un nome valido" graph-id)
  (or (gethash graph-id *graphs*)
  (setf (gethash graph-id *graphs*) graph-id))))

;;;; delete graph/1

(defun delete-graph (graph-id)
  (remhash graph-id *graphs*)
  (maphash (lambda (k v) 
             (if (equal (second k) graph-id) 
                 (remhash k *vertices*))
           ) *vertices*)
  (maphash (lambda (k v) 
             (if (equal (second k) graph-id) 
                 (remhash k *arcs*))
           ) *arcs*))

;;;; new vertex/2

(defun new-vertex (graph-id vertex-id)
  (if (is-graph graph-id)
  (setf (gethash (list 'vertex graph-id vertex-id) *vertices*)
        (list 'vertex graph-id vertex-id))
  (format t "Il grafo ~S non esiste" graph-id)))

;;;; graph vertices/1

(defun graph-vertices (graph-id)
  (if (not (is-graph graph-id))
      (format t "Il grafo ~S non esiste" graph-id)
    (let ((vertex-rep-list ()))
        (maphash (lambda (k v)
                   (if (equal (second k) graph-id)
                       (push v vertex-rep-list))
                   ) *vertices*)
        vertex-rep-list )))


;;;; new arc/4

(defun new-arc (graph-id vertex-id-1 vertex-id-2 &optional (weight 1))
  (cond ((and (gethash (list 'vertex graph-id vertex-id-1) *vertices*)
              (gethash (list 'vertex graph-id vertex-id-2) *vertices*)) 
    (and
      (setf (gethash (list 'arc graph-id vertex-id-1 vertex-id-2 weight) *arcs*)
            (list 'arc graph-id vertex-id-1 vertex-id-2 weight))
      (setf (gethash (list 'arc graph-id vertex-id-2 vertex-id-1 weight) *arcs*)
            (list 'arc graph-id vertex-id-2 vertex-id-1 weight))
      ))))

(defun find-arc (g u v)
  (or (gethash (list g u v) *arcs*)
      (gethash (list g v u) *arcs*)))

;;;; graph-arcs/1

(defun graph-arcs (graph-id)
  (if (is-graph graph-id)
      (let ((arc-rep-list ()))
        (maphash (lambda (k v)
                   (if (equal (second k) graph-id)
                       (push v arc-rep-list))
                   ) *arcs*)
        arc-rep-list)))

;;;; graph-vertex-neighbours

(defun graph-vertex-neighbors (graph-id vertex-id)
  (if (gethash (list 'vertex graph-id vertex-id) *vertices*)
      (let ((arc-rep-list ()))
        (maphash (lambda (k v)
                   (if (and (equal (second k) graph-id)
                            (equal (third k) vertex-id))
                       (push v arc-rep-list))
                   ) *arcs*)
        arc-rep-list)))

;;; graph-vertex-adjacent 

(defun graph-vertex-adjacent (graph-id vertex-id)
  (if (gethash (list 'vertex graph-id vertex-id) *vertices*)
      (let ((vertex-rep-list ()))
        (maphash (lambda (k v)
                   (if (and (equal (second k) graph-id)
                            (equal (third k) vertex-id))
                       (push (list 'vertex graph-id (fourth v)) vertex-rep-list))
                   ) *arcs*)
        vertex-rep-list)))

;;;; graph-print

(defun graph-print (graph-id)
  (if (is-graph graph-id)
      (append (graph-vertices graph-id) (graph-arcs graph-id))
    ))


;;;; new-heap

(defun new-heap (heap-id &optional (capacity 42))
  (or (gethash heap-id *heaps*)
      (setf (gethash heap-id *heaps*)
            (list 'heap heap-id 0 (make-array capacity)))))

;;;; is-heap

(defun is-heap (heap-id)
  (gethash heap-id *heaps*))

;;;; heap-delete

(defun heap-delete (heap-id)
  (remhash heap-id *heaps*))

;;;; heap-empty

(defun heap-empty (heap-id)
  (if (is-heap heap-id)
      (= (third (gethash heap-id *heaps*)) 0)))

;;;; heap-not-empty

(defun heap-not-empty (heap-id)
  (if (is-heap heap-id)
      (> (third (gethash heap-id *heaps*)) 0)))

(defun actual-heap (heap-id)
  (fourth (gethash heap-id *heaps*)))

(defun heap-head (heap-id)
  (if (is-heap heap-id)
      (aref (actual-heap heap-id) 0)))

(defun get-key (heap-id V)
  (first (gethash (list heap-id V) *heap-entries*)))

(defun get-pos (heap-id V)
  (second (gethash (list heap-id V) *heap-entries*)))
      

(defun get-parent (heap-id pos)
  (second (aref 
           (actual-heap heap-id)
           (max (floor (/ 
                   (1- pos) 
                   2)
                  )
                0)
           )))

(defun heap-size (heap-id)
  (third (gethash heap-id *heaps*)))

(defun incr-size (heap-id)
  (setf 
   (gethash heap-id *heaps*) 
   (list 'heap heap-id (1+ (heap-size heap-id)) (actual-heap heap-id)))) 

(defun decr-size (heap-id)
  (setf
   (gethash heap-id *heaps*)
   (list 'heap heap-id (1- (heap-size heap-id)) (actual-heap heap-id))))


;;;; heap-insert

(defun heap-insert (heap-id K V)
  (if (is-heap heap-id)
      (cond ((gethash (list heap-id V) *heap-entries*) ; se il vertice è dentro HEAP
             (if (> (get-key heap-id V) K) ; se Kold > Knew
                 (and 
                  (setf (gethash (list heap-id V) *heap-entries*) ; mod heap-entries
                       (list K (get-pos heap-id V) (get-parent heap-id (get-pos heap-id V))))
                  ; mod actual-heap
                  (setf (aref (actual-heap heap-id)
                              (get-pos heap-id V)) 
                        (list K V)) 
                  (heapify heap-id (heap-size heap-id) (get-pos heap-id V)))))
            (t (and ; aggiungo un nuovo heap entry 
                (incr-size heap-id)
                (setf (aref (actual-heap heap-id) (1- (heap-size heap-id))) (list K V))
                (setf (gethash (list heap-id V) *heap-entries*) ;aggiunge entry
                      (list K (1- (heap-size heap-id)) (get-parent heap-id (1- (heap-size heap-id)))))
                (heapify heap-id (heap-size heap-id) (1- (heap-size heap-id))))))))

(defun heapify (heap-id s i)
  (format t "heapify"))
                


   
; USO ADJUST-ARRAY PER CAMBIARE LA DIMENSIONE


;;; TEST

(new-graph 'my-graph)
(new-vertex 'my-graph 'v)
(new-vertex 'my-graph 'u)
(new-vertex 'my-graph 'z)
(new-arc 'my-graph 'u 'v)
(new-arc 'my-graph 'u 'z)
(new-heap 'my-heap)

;;;; end of file -- mst.lisp